"use strict";

// Обьект - это тип данных, который умеет хранить коллекции других типов данных и более сложные сущности
// При создании обьекта мы получаем ссылку на данные в памяти, а не прямой доступ к данным как в случае с примитивами.
// Поэтому при копировании объекта копируем ссылку область в памяти

// Как создать обьект

// const obj = {};
// const obj1 = new Object();

// Обьект хранит пары ключ-значение
// В качестве ключа может выступать: symbol, строка. Все остальные типы будут преобразовываться к строке
// Ключом может быть любое слово, даже зарезервированное. Но лучше так не делать, чтобы не вводить в заблуждение разработчиков
// let age = Symbol("age");

// const obj3 = {
//   name: "Pasha",
//   subrname: "Ivannikov",
//   1: 123, // ключ преобразуется к строке
// };

// obj3.age = 29;

// console.log("obj3 ", obj3);

// В обьект можно добавлять свойства после создания
// const obj4 = {};
// obj4.name = "Alex"; // так
// obj4["surname"] = "Ivanov"; // или так

// console.log("obj4 before ", obj4);

// delete obj4.name // а удалить свойство можно так

// console.log("obj4 after ", obj4);

// Проверить наличие свойства в обьекте можно
// console.log("name" in obj4); // так
// console.log(obj4.hasOwnProperty("name")); // или так

// let obj = {
//   test: undefined
// };

// что выведет?
// console.log(obj.test); //
// console.log("test" in obj); //

// перебор свойств обьекта можно сделать циклом for...in

// let user = {
//   name: "John",
//   age: 30,
//   isAdmin: true,
// };

// for (let key in user) {
//   // ключи
//   console.log(key); //
//   // значения ключей
//   console.log(user[key]); //
// }

// Упорядочивание свойств
// В обьекте не гарантировано упорядочивание свойств. Только если задавать ключам числовые значения

// let codes = {
//   49: "Германия",
//   41: "Швейцария",
//   44: "Великобритания",
//   // ..,
//   1: "США",
// };

// for (let code in codes) {
//   alert(code); // 1, 41, 44, 49
// }

// В остальных случаях перебор свойств будет осуществляться в порядке их создания

// let user = {
//   name: "John",
//   surname: "Smith"
// };
// user.age = 25; // добавим ещё одно свойство

// // не целочисленные свойства перечислены в порядке создания
// for (let prop in user) {
//   console.log( prop ); // name, surname, age
// }

// Копирование обьекта происходит по ссылке (т.е. копируется ссылка на область в памяти)

// let user = { name: "John" };

// let admin = user;

// admin.name = "Pete"; // изменено по ссылке из переменной "admin"

// console.log(user);
// console.log(admin);

// Равенство обьектов будет только в том случае, если это две ссылки на один и тот же обьект
// let a = {};
// let b = a; // копирование по ссылке

// console.log(a == b); // true, обе переменные ссылаются на один и тот же объект
// console.log(a === b); // true

// let a = {};
// let b = {}; // два независимых объекта

// console.log( a == b ); // false

// Клонирование обьекта
// Если нужно сделать дубликат обьекта, то придется заморочиться:

// Так
// let user = {
//   name: "John",
//   age: 30,
// };

// let clone = {}; // новый пустой объект

// for (let key in user) {
//   clone[key] = user[key];
// }

// console.log(user);
// console.log(clone);
// console.log(user == clone);

// Либо так:
// let clone2 = {};

// Object.assign(dest, [src1, src2, src3...])
// Object.assign(clone2, user);

// console.log(clone2);

// Если у обьекта есть вложенные обьекты, то нужно делать вложенное клонирование. В этом помогут такие библиотеки как lodash
// Функция в lodash: _.cloneDeep(obj)

// Методы обьекта
// В качестве значения обьекта может выступать функция. В этом случае функция называется методом обьекта
// let user = {
//   name: "John",
//   age: 30
// };

// user.sayHi = function() {
//   console.log("Привет!");
// };

// user.sayHi(); // Привет!

// Сокращенная запись метода:
// let user = {
//   sayHi() { // то же самое, что и "sayHi: function(){...}"
//     console.log("Привет");
//   }
// };

// Ключевое слово this
// Используется внутри обьекта/функции для указания на обьект, чье свойство мы хотим использовать

// let user = {
//   name: "John",
//   age: 30,

//   sayHi() {
//     // "this" - это "текущий объект".
//     alert(this.name);
//   }

// };

// user.sayHi(); // John

// let user = { name: "John" };
// let admin = { name: "Admin" };

// function sayHi() {
//   alert( this.name );
// }

// // используем одну и ту же функцию в двух объектах
// user.f = sayHi;
// admin.f = sayHi;

// // эти вызовы имеют  разное значение this
// // "this" внутри функции - это объект "перед точкой"
// user.f(); // John  (this == user)
// admin.f(); // Admin  (this == admin)

// admin['f'](); // Admin (нет разницы между использованием точки или квадратных скобок для доступа к объекту)

// Простыми словами: this.property - будет указывать на обьект, чье property мы хотим вызвать

// Object.keys, values, entries
// Поддерживаются для структур: Map, Set, Array

// Object.keys(obj) – возвращает массив ключей.
// Object.values(obj) – возвращает массив значений.
// Object.entries(obj) – возвращает массив пар [ключ, значение].

// Задачи:

// 1. Напишите функцию count(obj), которая возвращает количество свойств объекта:
// let user = {
//   name: 'John',
//   age: 30
// };

// console.log( count(user) ); // 2

// 2. Напишите функцию isEmpty(obj), которая возвращает true, если у объекта нет свойств, иначе false.
// let schedule = {};

// alert( isEmpty(schedule) ); // true

// schedule["8:30"] = "get up";

// alert( isEmpty(schedule) ); // false

// 3. Можно ли изменить объект, объявленный с помощью const? Как вы думаете?
// const user = {
//   name: "John"
// };

// // это будет работать?
// user.name = "Pete";

// 4. Напишите код для суммирования всех зарплат и сохраните результат в переменной sum. Должно получиться 390.

// let salaries = {
//   John: 100,
//   Ann: 160,
//   Pete: 130
// }

// 5. Создайте функцию multiplyNumeric(obj), которая умножает все числовые свойства объекта obj на 2.
// // до вызова функции
// let menu = {
//   width: 200,
//   height: 300,
//   title: "My menu"
// };

// multiplyNumeric(menu);

// // после вызова функции
// menu = {
//   width: 400,
//   height: 600,
//   title: "My menu"
// };

// Обратите внимание, что multiplyNumeric не нужно ничего возвращать. Следует напрямую изменять объект.
// P.S. Используйте typeof для проверки, что значение свойства числовое.

// 6. Здесь функция makeUser возвращает объект. Каким будет результат при обращении к свойству объекта ref? Почему?
// function makeUser() {
//   return {
//     name: "John",
//     ref: this
//   };
// }

// let user = makeUser();

// alert( user.ref.name ); // Каким будет результат?

// 7. Создайте объект calculator (калькулятор) с тремя методами:
// read() (читать) запрашивает два значения и сохраняет их как свойства объекта с именами a и b.
// sum() (суммировать) возвращает сумму сохранённых значений.
// mul() (умножить) перемножает сохранённые значения и возвращает результат.
// let calculator = {
//   // ... ваш код ...
// };

// calculator.read();
// alert(calculator.sum());
// alert(calculator.mul());

// 8. У нас есть объект ladder (лестница), который позволяет подниматься и спускаться:
// let ladder = {
//   step: 0,
//   up() {
//     this.step++;
//   },
//   down() {
//     this.step--;
//   },
//   showStep: function() { // показывает текущую ступеньку
//     alert( this.step );
//   }
// };

// Теперь, если нам нужно выполнить несколько последовательных вызовов, мы можем сделать это так:

// ladder.up();
// ladder.up();
// ladder.down();
// ladder.showStep(); // 1
// ladder.down();
// ladder.showStep(); // 0

// Измените код методов up, down и showStep таким образом, чтобы их вызов можно было сделать по цепочке, например так:

// ladder.up().up().down().showStep().down().showStep(); // показывает 1 затем 0

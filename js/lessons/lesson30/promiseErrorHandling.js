// Самый лёгкий путь перехватить все ошибки – это добавить .catch в конец цепочки:

// fetch('/article/promise-chaining/user.json')
//   .then(response => response.json())
//   .then(user => fetch(`https://api.github.com/users/${user.name}`))
//   .then(response => response.json())
//   .then(githubUser => new Promise((resolve, reject) => {
//     let img = document.createElement('img');
//     img.src = githubUser.avatar_url;
//     img.className = "promise-avatar-example";
//     document.body.append(img);

//     setTimeout(() => {
//       img.remove();
//       resolve(githubUser);
//     }, 3000);
//   }))
//   .catch(error => console.log(error.message));

// Неявный try…catch

// Например, этот код:

// new Promise((resolve, reject) => {
//   throw new Error("Ошибка!");
// }).catch(console.log); // Error: Ошибка!

// …Работает так же, как и этот:

// new Promise((resolve, reject) => {
//   reject(new Error("Ошибка!"));
// }).catch(console.log); // Error: Ошибка!

// Пробрасывание ошибок

// the execution: catch -> then
// new Promise((resolve, reject) => {
//   throw new Error("Ошибка!");
// }).catch(function(error) {
//   console.log("Ошибка обработана, продолжить работу");
// }).then(() => console.log("Управление перейдёт в следующий then"));

// В примере ниже мы видим другую ситуацию с блоком .catch. Обработчик (*) перехватывает ошибку и не может обработать её (например, он знает как обработать только URIError), поэтому ошибка пробрасывается далее:

// the execution: catch -> catch -> then
// new Promise((resolve, reject) => {
//   throw new Error("Ошибка!");
// })
//   .catch(function (error) {
//     // (*)
//     if (error instanceof URIError) {
//       // обрабатываем ошибку
//     } else {
//       console.log("Не могу обработать ошибку");
//       throw error; // пробрасывает эту или другую ошибку в следующий catch
//     }
//   })
//   .then(function () {
//     /* не выполнится */
//   })
//   .catch((error) => {
//     // (**)
//     console.log(`Неизвестная ошибка: ${error}`);
//     // ничего не возвращаем => выполнение продолжается в нормальном режиме
//   });

// Что произойдёт, если ошибка не будет обработана? Например, мы просто забыли добавить .catch в конец цепочки, как здесь:
// new Promise(function () {
//   noSuchFunction(); // Ошибка (нет такой функции)
// }).then(() => {
//   // обработчики .then, один или более
// }); // без .catch в самом конце!

// В случае ошибки выполнение должно перейти к ближайшему обработчику ошибок. Но в примере выше нет никакого обработчика. Поэтому ошибка как бы «застревает», её некому обработать.

// На практике, как и при обычных необработанных ошибках в коде, это означает, что что-то пошло сильно не так.

// Что происходит, когда обычная ошибка не перехвачена try..catch? Скрипт умирает с сообщением в консоли. Похожее происходит и в случае необработанной ошибки промиса.

// JavaScript-движок отслеживает такие ситуации и генерирует в этом случае глобальную ошибку. Вы можете увидеть её в консоли, если запустите пример выше.

// В браузере мы можем поймать такие ошибки, используя событие unhandledrejection:

// window.addEventListener('unhandledrejection', function(event) {
//   // объект события имеет два специальных свойства:
//   console.log(event.promise); // [object Promise] - промис, который сгенерировал ошибку
//   console.log(event.reason); // Error: Ошибка! - объект ошибки, которая не была обработана
// });

// new Promise(function() {
//   throw new Error("Ошибка!");
// }); // нет обработчика ошибок

// Это событие является частью стандарта HTML.

// Если происходит ошибка, и отсутствует её обработчик, то генерируется событие unhandledrejection, и соответствующий объект event содержит информацию об ошибке.

// Обычно такие ошибки неустранимы, поэтому лучше всего – информировать пользователя о проблеме и, возможно, отправить информацию об ошибке на сервер.

// В не-браузерных средах, таких как Node.js, есть другие способы отслеживания необработанных ошибок.

//  Резюме:
// - Промис - это обьект, у которого есть state и result. State может находиться в 3 значениях "penging" - промис выполняется, fulfilled - промис выполнился успешно и вернул значение (resolve(value)), rejected - промис выполнился с ошибкой и вернул значение в reject(err)
// - Если обработчик в .then (или в catch/finally, без разницы) возвращает промис, последующие элементы цепочки ждут, пока этот промис выполнится. Когда это происходит, результат его выполнения (или ошибка) передаётся дальше.
// - .catch перехватывает все виды ошибок в промисах: будь то вызов reject() или ошибка, брошенная в обработчике при помощи throw.
// - .then также перехватывает ошибки таким же образом, если задан второй аргумент (который является обработчиком ошибок).
// - Необходимо размещать .catch там, где мы хотим обработать ошибки и знаем, как это сделать. Обработчик может проанализировать ошибку (могут быть полезны пользовательские классы ошибок) и пробросить её, если ничего не знает о ней (возможно, это программная ошибка).
// - Можно и совсем не использовать .catch, если нет нормального способа восстановиться после ошибки.
// - В любом случае нам следует использовать обработчик события unhandledrejection (для браузеров и аналог для других окружений), чтобы отслеживать необработанные ошибки и информировать о них пользователя (и, возможно, наш сервер), благодаря чему наше приложение никогда не будет «просто умирать».

// Задачи:
// 1)
// Что вы думаете? Выполнится ли .catch? Поясните свой ответ.
// new Promise(function(resolve, reject) {
//   setTimeout(() => {
//     throw new Error("Whoops!");
//   }, 1000);
// }).catch(alert);

// Свойство "prototype" широко используется внутри самого языка JavaScript. Все встроенные функции-конструкторы используют его.

// Сначала мы рассмотрим детали, а затем используем "prototype" для добавления встроенным объектам новой функциональности.

// let obj = {};
// let obj1 = new Object();
// console.log(obj); // "[object Object]" ?

// Строка [object Object] берется из Object.prototype, поскольку let obj = {} тоже самое что и let obj = new Object()

// Это значит что в свойстве prototype для функции-конструктора Object есть огромный обьект с большим количеством методов.

// Кстати, у других функций-прототипов для наших типов данных тоже есть свой prototype.

// Проверим:
// let obj = {};
// console.log(obj.__proto__ === Object.prototype); // true
// obj.toString === obj.__proto__.toString === Object.prototype.toString

// Кстати, в цепочке прототипов выше уже ничего нет:
// console.log(Object.prototype.__proto__); // null

// Схематично цепочка прототипов может выглядеть так:

//                          null
//                            |
//                            |
//                    Object.prototype
//          |                 |                  |
//          |                 |                  |
//   Array.prototype, Function.prototype, Number.prototype ...
//          |                 |                  |
//          |                 |                  |
//      [1, 2, 3]       function f() {}          5

// let arr = [1, 2, 3];
// // наследует ли от Array.prototype?
// console.log(arr.__proto__ === Array.prototype); //

// // затем наследует ли от Object.prototype?
// console.log(arr.__proto__.__proto__ === Object.prototype); //

// // и null на вершине иерархии
// console.log(arr.__proto__.__proto__.__proto__); //

// Некоторые методы в прототипах могут пересекаться, например, у Array.prototype есть свой метод toString, который выводит элементы массива через запятую:
// let arr = [1, 2, 3];
// console.log(arr.toString()); // 1,2,3 <-- результат Array.prototype.toString

// let obj = {
//   name: "Pasha",
// };
// console.log(obj.toString());

// Как мы видели ранее, у Object.prototype есть свой метод toString, но так как Array.prototype ближе в цепочке прототипов, то берётся именно вариант для массивов

// В браузерных инструментах, таких как консоль разработчика, можно посмотреть цепочку наследования (возможно, потребуется использовать console.dir для встроенных объектов):
// console.dir([1, 2, 3])

// Другие встроенные объекты устроены аналогично. Даже функции – они объекты встроенного конструктора Function, и все их методы (call/apply и другие) берутся из Function.prototype. Также у функций есть свой метод toString.
// function f() {}

// console.log(f.__proto__ == Function.prototype); //
// console.log(f.__proto__.__proto__ == Object.prototype); //

// Примитивы
// Самое сложное происходит со строками, числами и булевыми значениями.

// Как мы помним, они не объекты. Но если мы попытаемся получить доступ к их свойствам, то тогда будет создан временный объект-обёртка с использованием встроенных конструкторов String, Number и Boolean, который предоставит методы и после этого исчезнет.

// Эти объекты создаются невидимо для нас, и большая часть движков оптимизирует этот процесс, но спецификация описывает это именно таким образом. Методы этих объектов также находятся в прототипах, доступных как String.prototype, Number.prototype и Boolean.prototype.

// Значения null и undefined не имеют объектов-обёрток
// Специальные значения null и undefined стоят особняком. У них нет объектов-обёрток, так что методы и свойства им недоступны. Также у них нет соответствующих прототипов.

// Изменение встроенных прототипов
// Встроенные прототипы можно изменять. Например, если добавить метод к String.prototype, метод становится доступен для всех строк:
// String.prototype.show = function () {
//   console.log("I am");
// };

// let str = "Pasha";

// str.show();

// В течение процесса разработки у нас могут возникнуть идеи о новых встроенных методах, которые нам хотелось бы иметь, и искушение добавить их во встроенные прототипы. Это плохая идея.

// Потому что прототипы глобальны, поэтому очень легко могут возникнуть конфликты. Если две библиотеки добавляют метод String.prototype.show, то одна из них перепишет метод другой.
// Так что, в общем, изменение встроенных прототипов считается плохой идеей.

// В современном программировании есть только один случай, в котором одобряется изменение встроенных прототипов. Это создание полифилов.

// Полифил – это термин, который означает эмуляцию метода, который существует в спецификации JavaScript, но ещё не поддерживается текущим движком JavaScript.

// Тогда мы можем реализовать его сами и добавить во встроенный прототип.

// Например:
// if (!String.prototype.repeat) { // Если такого метода нет
//   // добавляем его в прототип

//   String.prototype.repeat = function(n) {
//     // повторить строку n раз

//     // на самом деле код должен быть немного более сложным
//     // (полный алгоритм можно найти в спецификации)
//     // но даже неполный полифил зачастую достаточно хорош для использования
//     return new Array(n + 1).join(this);
//   };
// }

// console.log( "La".repeat(3) ); // LaLaLa

// Заимствование у прототипов
// Это когда мы берём метод из одного объекта и копируем его в другой.
// Некоторые методы встроенных прототипов часто одалживают.
// Например, если мы создаём объект, похожий на массив (псевдомассив), мы можем скопировать некоторые методы из Array в этот объект.

// Пример:
// let obj = {
//   0: "Hello",
//   1: "world!",
//   length: 2,
// };

// obj.join = Array.prototype.join;
// console.log(obj.join(",")); // Hello,world!

// Это работает, потому что для внутреннего алгоритма встроенного метода join важны только корректность индексов и свойство length, он не проверяет, является ли объект на самом деле массивом. И многие встроенные методы работают так же.

// Задачи:

// 1)
// Добавьте всем функциям в прототип метод defer(ms), который вызывает функции через ms миллисекунд.

// После этого должен работать такой код:
// function defer(ms) {
//   setTimeout(this, ms);
// }

// Function.prototype.defer = defer;

// function f() {
//   console.log("Hello!");
// }

// f.defer(1000); // выведет "Hello!" через 1 секунду

// 2)
// Добавьте всем функциям в прототип метод defer(ms), который возвращает обёртку, откладывающую вызов функции на ms миллисекунд.

// Например, должно работать так:
// function defer(ms) {
//   let f = this;
//   return function (...args) {
//     setTimeout(() => f.apply(this, args), ms);
//   };
// }

// Function.prototype.defer = defer;

// function func(a, b) {
//   console.log(a + b);
// }

// const wrappedF = func.defer(1000); // function ...
// console.log(typeof wrappedF); // function
// wrappedF(3, 5);
// Пожалуйста, заметьте, что аргументы должны корректно передаваться оригинальной функции.

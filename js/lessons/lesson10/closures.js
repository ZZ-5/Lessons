// Замыкания
// Замыкание – это функция, которая запоминает свои внешние переменные и может получить к ним доступ.
// Другими словами: замыкание - это когда функция берёт переменные из внешнего лексического окружения.

function myFunc() {
  let value = 123;

  return function () {
    console.log(value);
  };
}

let g = myFunc(); // Создаем Func Exec Context для f().
// g.[[Environment]] хранит ссылку на лексическое окружение
// из соответствующего вызова f()

// Как мы помним, на каждый новый вызов функци создается Function Execution context, который кладётся вверх Call stack-а. В FEC есть привязанный this, LexicalEnvironment и VariableEnvironment.

// Пример, где можно увидеть что Function Execution context действительно создается для каждого нового вызова функции

let counter = 0;

function f() {
  let value = Math.random(); // эта переменная будет разная на каждый вызов

  counter++; // counter находится во внешнем LexicalEnvironment, а не внутри функции, поэтому будет увеличиваться на 1 за каждый вызов функции f
  console.log(`call ${counter}, value is: `, value); // используем counter чтобы показывать номер вызова фукнции f и текущее значение value в этом вызове

  return function () {
    return value;
  };
}

// 3 функции в массиве, каждая из которых ссылается на лексическое окружение
// из соответствующего вызова f()
let a = f()(); // делаем повторный вызов чтобы вызвать ту функцию, которая вернется из f и вернёт value
let b = f()();
let c = f()();

let arr = [a, b, c];

console.log(arr);

// Сборка мусора
// Когда мы работаем с языками программирования, мы также работаем с памятью и вычислительными мощностями нашего компьютера. При создании переменных и обьявлении функций мы выделяем память, в которой они будут храниться.
// Логично предположить что переменные и функции из нашего скрипта должны в какой-то момент исчезнуть из памяти, иначе память забьется. В языках программирования удаление ненужных данных из памяти называется сборкой мусора.

// Как мы уже знаем, после того как функция отработала, мы удаляем её Function Execution Context. В этот момент и происходит очищение памяти.

// Но что будет в случае с замыканием? Мы же вызываем f, которая возвращает другую функцию. Фактически после возврата функции f завершила свою работу. Но не совсем. В случае с замыканием внешнее лексическое окружение будет доступным для фукнции, которая на него ссылается, до того момента, пока она ни завершит свою работу.

// Пара дополнений про сборку мусора в js
// 1) В отличие от некоторых других языков программирования сборка мусора в JS выполняется автоматически.
// 2) Обьекты сохраняются в памяти до тех пор, пока они достижимы. По этой же причине сохраняется лексическое окружение функции f из нашего примера: оно всё ещё необходимо внутренней функции
// 3) С другой стороны, иногда такое поведение может попасть под оптимизацию движка браузера и мы можем потерять доступ к переменной из замыкания (например, в отладчике chrome).

// Больше о сборке мусора: https://learn.javascript.ru/garbage-collection

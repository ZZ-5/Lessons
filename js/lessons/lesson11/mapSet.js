"user strict";
// Map – это коллекция ключ/значение, как и Object. Но основное отличие в том, что Map позволяет использовать ключи любого типа.

// new Map() – создаёт коллекцию.
// map.set(key, value) – записывает по ключу key значение value.
// map.get(key) – возвращает значение по ключу или undefined, если ключ key отсутствует.
// map.has(key) – возвращает true, если ключ key присутствует в коллекции, иначе false.
// map.delete(key) – удаляет элемент (пару «ключ/значение») по ключу key.
// map.clear() – очищает коллекцию от всех элементов.
// map.size – возвращает текущее количество элементов.

// let map = new Map();

// map.set("1", "str1");    // строка в качестве ключа
// map.set(1, "num1");      // цифра как ключ
// map.set(true, "bool1");  // булево значение как ключ

// // помните, обычный объект Object приводит ключи к строкам?
// // Map сохраняет тип ключей, так что в этом случае сохранится 2 разных значения:
// console.log(map.get(1)); //
// console.log(map.get("1")); //

// console.log(map.size); //

// Чтобы задать новое свойство можно сделать map[key], но лучше всегда использовать методы set и get. Иначе map будет рассматриваться как обычный обьект

// Map может использовать объекты в качестве ключей.
// Например:
// let john = { name: "John" };

// // давайте сохраним количество посещений для каждого пользователя
// let visitsCountMap = new Map();

// // объект john - это ключ для значения в объекте Map
// visitsCountMap.set(john, 123);
// console.log(visitsCountMap.get(john)); // 123

// Для перебора коллекции Map есть 3 метода:

// map.keys() – возвращает итерируемый объект по ключам,
// map.values() – возвращает итерируемый объект по значениям,
// map.entries() – возвращает итерируемый объект по парам вида [ключ, значение], этот вариант используется по умолчанию в for..of

// let recipeMap = new Map([
//   ["огурец", 500],
//   ["помидор", 350],
//   ["лук",    50]
// ]);

// // перебор по ключам (овощи)
// for (let vegetable of recipeMap.keys()) {
//   console.log(vegetable); // огурец, помидор, лук
// }

// // перебор по значениям (числа)
// for (let amount of recipeMap.values()) {
//   console.log(amount); // 500, 350, 50
// }

// // перебор по элементам в формате [ключ, значение]
// for (let entry of recipeMap) { // то же самое, что и recipeMap.entries()
//   console.log(entry); // огурец,500 (и так далее)
// }

// у Map есть встроенный метод forEach
// выполняем функцию для каждой пары (ключ, значение)
// recipeMap.forEach((value, key, map) => {
//   console.log(`${key}: ${value}`); // огурец: 500 и так далее
// });

// При создании Map мы можем указать массив (или другой итерируемый объект) с парами ключ-значение для инициализации, как здесь:
// массив пар [ключ, значение]
// let map = new Map([
//   ['1',  'str1'],
//   [1,    'num1'],
//   [true, 'bool1']
// ]);

// console.log( map.get('1') ); // str1

// Если у нас уже есть обьект и мы хотим сделать из него Map, то это проще всего сделать через Object.entries
// let obj = {
//   name: "John",
//   age: 30,
// };

// let map = new Map(Object.entries(obj));
// console.log(map.get("name")); // John

// Также можно сделать обратную операцию из массива пар в обьект:
// let prices = Object.fromEntries([
//   ['banana', 1],
//   ['orange', 2],
//   ['meat', 4]
// ]);

// console.log(prices); // 2

// или из Map в обьект:
// let map = new Map();
// map.set('banana', 1);
// map.set('orange', 2);
// map.set('meat', 4);

// let obj = Object.fromEntries(map); // создаём обычный объект (*)
// console.log(obj.orange); // 2

// Объект Set – это особый вид коллекции: «множество» значений (без ключей), где каждое значение может появляться только один раз.
// new Set(iterable) – создаёт Set, и если в качестве аргумента был предоставлен итерируемый объект (обычно это массив), то копирует его значения в новый Set.
// set.add(value) – добавляет значение (если оно уже есть, то ничего не делает), возвращает тот же объект set.
// set.delete(value) – удаляет значение, возвращает true, если value было в множестве на момент вызова, иначе false.
// set.has(value) – возвращает true, если значение присутствует в множестве, иначе false.
// set.clear() – удаляет все имеющиеся значения.
// set.size – возвращает количество элементов в множестве.

// Основная «изюминка» – это то, что при повторных вызовах set.add() с одним и тем же значением ничего не происходит, за счёт этого как раз и получается, что каждое значение появляется один раз.

// let set = new Set();

// let john = { name: "John" };
// let pete = { name: "Pete" };
// let mary = { name: "Mary" };

// // считаем гостей, некоторые приходят несколько раз
// set.add(john);
// set.add(pete);
// set.add(mary);
// set.add(john);
// set.add(mary);

// // set хранит только 3 уникальных значения
// console.log(set.size); // 3

// for (let user of set) {
//   console.log(user.name); // John (потом Pete и Mary)
// }

// В этом плане Set похож на массив уникальных значений, но с набором методов как у Map

// Set также можно перебрать с помощью forEach:
// let set = new Set(["апельсин", "яблоко", "банан"]);

// for (let value of set) alert(value);

// // то же самое с forEach:
// set.forEach((value, valueAgain, set) => {
//   alert(value);
// });

// Заметим забавную вещь. Функция в forEach у Set имеет 3 аргумента: значение value, потом снова то же самое значение valueAgain, и только потом целевой объект. Это действительно так, значение появляется в списке аргументов дважды.

// Это сделано для совместимости с объектом Map, в котором колбэк forEach имеет 3 аргумента. Выглядит немного странно, но в некоторых случаях может помочь легко заменить Map на Set и наоборот.

// Set имеет те же встроенные методы, что и Map:

// set.keys() – возвращает перебираемый объект для значений,
// set.values() – то же самое, что и set.keys(), присутствует для обратной совместимости с Map,
// set.entries() – возвращает перебираемый объект для пар вида [значение, значение], присутствует для обратной совместимости с Map.

// Задачи:

// 1) Допустим, у нас есть массив arr.
// Создайте функцию unique(arr), которая вернёт массив уникальных, не повторяющихся значений массива arr.
// Например:
// function unique(arr) {
//   /* ваш код */
// }

// let values = ["Hare", "Krishna", "Hare", "Krishna",
//   "Krishna", "Krishna", "Hare", "Hare", ":-O"
// ];

// alert( unique(values) ); // Hare,Krishna,:-O

// 2) Анаграммы – это слова, у которых те же буквы в том же количестве, но они располагаются в другом порядке.
// Например:
// nap - pan
// ear - are - era
// cheaters - hectares - teachers

// Напишите функцию aclean(arr), которая возвращает массив слов, очищенный от анаграмм.
// Например:
// let arr = ["nap", "teachers", "cheaters", "PAN", "ear", "era", "hectares"];
// console.log( aclean(arr) ); // "nap,teachers,ear" или "PAN,cheaters,era"

// 3) Мы хотели бы получить массив ключей map.keys() в переменную и далее работать с ними, например, применить метод .push.
// Но это не выходит:

// let map = new Map();
// map.set("name", "John");
// let keys = map.keys();

// // Error: keys.push is not a function
// // Ошибка: keys.push -- это не функция
// keys.push("more");

// Почему? Что нужно поправить в коде, чтобы вызов keys.push сработал?
